# Azure DevOps Pipeline: AKS Store Demo
# Multi-Stage Pipeline for Infrastructure, Build, and Deploy
#
# STAGES:
# 1. Terraform - Plan/Apply infrastructure changes
# 2. Build - Build and push Docker images to ACR
# 3. Deploy - Helm upgrade to AKS
#
# Prerequisites:
# 1. Kubernetes service connection 'aks-dev'
# 2. Azure service connection 'azure-sub' (for Terraform + ACR)
# 3. Self-hosted agent pool 'Default'

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'charts/**'
      - 'src/**'
      - 'infra/terraform/**'
      - 'azure-pipelines.yml'

pr: none

parameters:
  - name: runTerraform
    displayName: 'Run Terraform (infrastructure changes)?'
    type: boolean
    default: false
  - name: buildImages
    displayName: 'Build and push Docker images?'
    type: boolean
    default: true
  - name: deployHelm
    displayName: 'Deploy with Helm?'
    type: boolean
    default: true

variables:
  kubernetesServiceConnection: 'aks-dev'
  azureServiceConnection: 'azure-sub'
  acrName: 'acrdevcattle65'
  resourceGroup: 'rg-devcattle65'
  chartPath: 'charts/aks-store-demo'
  releaseName: 'aks-store'
  terraformWorkingDir: 'infra/terraform'

stages:
  # ============================================
  # STAGE 1: TERRAFORM
  # ============================================
  - stage: Terraform
    displayName: 'Infrastructure (Terraform)'
    condition: eq('${{ parameters.runTerraform }}', 'True')
    jobs:
      - job: TerraformPlanApply
        displayName: 'Terraform Plan & Apply'
        pool:
          name: 'Default'
        steps:
          - checkout: self

          - task: TerraformInstaller@1
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '1.11.0'

          - task: TerraformCLI@2
            displayName: 'Terraform Init'
            inputs:
              command: 'init'
              workingDirectory: '$(terraformWorkingDir)'
              backendType: 'azurerm'
              backendServiceArm: '$(azureServiceConnection)'
              backendAzureRmResourceGroupName: 'rg-terraform-state'
              backendAzureRmStorageAccountName: 'stterrafstate28f196d4'
              backendAzureRmContainerName: 'tfstate'
              backendAzureRmKey: 'rosetta.tfstate'

          - task: TerraformCLI@2
            displayName: 'Terraform Plan'
            inputs:
              command: 'plan'
              workingDirectory: '$(terraformWorkingDir)'
              environmentServiceName: '$(azureServiceConnection)'
              commandOptions: '-var-file=dev.tfvars.json -out=tfplan'

          - task: TerraformCLI@2
            displayName: 'Terraform Apply'
            inputs:
              command: 'apply'
              workingDirectory: '$(terraformWorkingDir)'
              environmentServiceName: '$(azureServiceConnection)'
              commandOptions: 'tfplan'

  # ============================================
  # STAGE 2: BUILD IMAGES
  # ============================================
  - stage: Build
    displayName: 'Build Docker Images'
    dependsOn: Terraform
    condition: and(not(failed('Terraform')), eq('${{ parameters.buildImages }}', 'True'))
    jobs:
      - job: BuildImages
        displayName: 'Build and Push to ACR'
        pool:
          name: 'Default'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Build order-service'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr build --registry $(acrName) \
                  --image order-service:$(Build.BuildId) \
                  --image order-service:latest \
                  --file src/order-service/Dockerfile \
                  src/order-service/

          - task: AzureCLI@2
            displayName: 'Build product-service'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr build --registry $(acrName) \
                  --image product-service:$(Build.BuildId) \
                  --image product-service:latest \
                  --file src/product-service/Dockerfile \
                  src/product-service/

          - task: AzureCLI@2
            displayName: 'Build store-front'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr build --registry $(acrName) \
                  --image store-front:$(Build.BuildId) \
                  --image store-front:latest \
                  --file src/store-front/Dockerfile \
                  src/store-front/

          - task: AzureCLI@2
            displayName: 'Build store-admin'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr build --registry $(acrName) \
                  --image store-admin:$(Build.BuildId) \
                  --image store-admin:latest \
                  --file src/store-admin/Dockerfile \
                  src/store-admin/

  # ============================================
  # STAGE 3: DEPLOY TO DEV
  # ============================================
  - stage: DeployDev
    displayName: 'Deploy to Dev'
    dependsOn: Build
    condition: and(not(failed('Build')), eq('${{ parameters.deployHelm }}', 'True'))
    variables:
      namespace: 'dev'
      valuesFile: 'values-dev.yaml'
    jobs:
      - deployment: DeployHelmDev
        displayName: 'Deploy via Helm (Dev)'
        pool:
          name: 'Default'
        environment: 'dev'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: HelmInstaller@0
                  displayName: 'Install Helm'
                  inputs:
                    helmVersion: '3.14.0'

                - task: Kubernetes@1
                  displayName: 'Create Namespace'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                    command: 'apply'
                    useConfigurationFile: true
                    configurationType: 'inline'
                    inline: |
                      apiVersion: v1
                      kind: Namespace
                      metadata:
                        name: $(namespace)
                        labels:
                          environment: dev

                - task: HelmDeploy@0
                  displayName: 'Helm Upgrade/Install'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                    namespace: $(namespace)
                    command: 'upgrade'
                    chartType: 'FilePath'
                    chartPath: $(chartPath)
                    releaseName: $(releaseName)
                    install: true
                    waitForExecution: true
                    arguments: '-f $(chartPath)/$(valuesFile) --timeout 5m'

                - task: Kubernetes@1
                  displayName: 'Verify Pods'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                    namespace: $(namespace)
                    command: 'get'
                    arguments: 'pods -o wide'

                - task: Kubernetes@1
                  displayName: 'Get Services'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(kubernetesServiceConnection)
                    namespace: $(namespace)
                    command: 'get'
                    arguments: 'svc'

  # ============================================
  # STAGE 4: DEPLOY TO PROD (with approval)
  # ============================================
  # Uncomment when ready for production
  # - stage: DeployProd
  #   displayName: 'Deploy to Prod'
  #   dependsOn: DeployDev
  #   condition: succeeded()
  #   variables:
  #     namespace: 'prod'
  #     valuesFile: 'values-prod.yaml'
  #   jobs:
  #     - deployment: DeployHelmProd
  #       displayName: 'Deploy via Helm (Prod)'
  #       pool:
  #         name: 'Default'
  #       environment: 'prod'  # Add approval gate in Azure DevOps UI
  #       strategy:
  #         runOnce:
  #           deploy:
  #             steps:
  #               # Same steps as dev...
