# ==============================================================================
# ServiceAccounts for Workload Identity
# ==============================================================================
# 
# ARCHITECTURE THOUGHT PROCESS:
#
# These ServiceAccounts are linked to an Azure Managed Identity via "federated
# credentials" created in Terraform. When a pod uses one of these ServiceAccounts:
#
# 1. K8s injects an OIDC token into the pod (via a projected volume)
# 2. Azure SDK's DefaultAzureCredential() discovers this token
# 3. SDK exchanges the token with Azure AD for an Azure access token
# 4. Pod can now call Azure services (Key Vault) without any secrets!
#
# The annotation `azure.workload.identity/client-id` tells the Azure SDK which
# Azure identity to assume. The label `azure.workload.identity/use: "true"`
# tells the AKS mutating webhook to inject the necessary volume mounts.
#
# AWS Equivalent: IAM Roles for Service Accounts (IRSA)
# ==============================================================================

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: order-service
  namespace: {{ .Values.namespace | default "dev" }}
  labels:
    app.kubernetes.io/name: order-service
    app.kubernetes.io/managed-by: {{ .Release.Service }}
  annotations:
    # This tells Azure SDK which identity to assume
    azure.workload.identity/client-id: {{ .Values.workloadIdentity.clientId | quote }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: product-service
  namespace: {{ .Values.namespace | default "dev" }}
  labels:
    app.kubernetes.io/name: product-service
    app.kubernetes.io/managed-by: {{ .Release.Service }}
  annotations:
    azure.workload.identity/client-id: {{ .Values.workloadIdentity.clientId | quote }}
